# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['print_all', 'children', 'recursively_apply_to_children', 'bn_to_tanh', 'AdjustNormFunc', 'tanSigmoid',
           'gaussian', 'TanHNorm', 'TanSigmoidNorm', 'GaussianNorm', 'recursive_getattr', 'recursive_setattr',
           'modify_network']

# Cell
import torch.nn as nn
from functools import partial
import torchvision.models as models
import torch
from typing import Callable

# Cell
def print_all(*args, **kwargs):
    "Prints all arguments passed in separate lines"
    for arg in args: print(arg)
    for key in kwargs.keys(): print(f'{key} : {kwargs[key]}')

# Cell
def children(m:nn.Module):
    "get a list of children modules of `m`"
    return list(m.children())

# Cell
def recursively_apply_to_children(m, f):
    "Apply `f` recursively to all the children of `m`"
    kids = children(m)
    if isinstance(m, nn.Module): f(m)
    for child in kids: recursively_apply_to_children(child, f)

# Cell
def bn_to_tanh(m):
    if isinstance(m, nn.BatchNorm2d):
        nf = m.num_features
        m = TanHNorm(nf)
    return m

# Cell
class AdjustNormFunc(nn.Module):
    "Creates a BatchNorm-like module using func : x = func(x) * scale + shift"
    def __init__(self, nf, func=torch.tanh, name=None):
        super().__init__()
        self.func = func
        self.name = name
        self.nf = nf
        self.scale = nn.Parameter(torch.ones (nf, 1, 1))
        self.shift = nn.Parameter(torch.zeros(nf, 1, 1))

    def forward(self, x):
        x = self.func(x)
        return x * self.scale + self.shift

    def __str__(self):
        if self.name:
            return "Adjusted " + self.name + f'({self.nf})'
        return "Adjusted " + self.func.__str__() + f'({self.nf})'

    def __repr__(self):
        return self.__str__()

# Cell
def tanSigmoid(x:torch.Tensor)->torch.Tensor: return torch.sigmoid(x) * 2 - 1

# Cell
def gaussian(x:torch.Tensor)->torch.Tensor: return torch.exp(-x)

# Cell
TanHNorm = partial(AdjustNormFunc, func=torch.tanh, name='TanH')
TanSigmoidNorm = partial(AdjustNormFunc, func=tanSigmoid, name='TanSigmoid')
GaussianNorm = partial(AdjustNormFunc, func=gaussian, name='Gaussian')

# Cell
def recursive_getattr(obj:nn.Module, name:str):
    """ getattr for nested attributes with `.` in their names """
    sequence = name.split('.')
    if len(sequence) == 0 or name == '': return obj
    for attr in sequence: obj = getattr(obj, attr)
    return obj

def recursive_setattr(obj:nn.Module, name:str, new_attr):
    """ setattr for nested attributes with `.` in their names """
    sequence = name.split('.')
    obj = recursive_getattr(obj, '.'.join(sequence[:-1]))
    setattr(obj, sequence[-1], new_attr)

def modify_network(m:nn.Module, replace_func:Callable, condition:Callable=None)->nn.Module:
    """ modifies `m` by replacing each module that satisfies `condition`
        with replace_func(module) """
    if condition is None:
        # If `replace_func` has a condition in-built it should return
        # the passed module as it is. This is to prevent a recursion issue.
        condition = (lambda x: not x == replace_func(x))

    modules = list(m.named_modules())
    if len(modules) == 1:
        return replace_func(m)
    for name, module in modules:
        if condition(module):
            recursive_setattr(m, name, replace_func(module))
    return m